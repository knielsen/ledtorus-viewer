/*
  gcc -Wall ledtorus2_anim.c simplex_noise.c colours.c -o ledtorus2_anim -lm
*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

#include "ledtorus2_anim.h"
#include "simplex_noise.h"
#include "colours.h"

/*
   A factor to compensate that pixels are much smaller in the tangential
   direction than in the radial and vertical direction.
*/
static const float tang_factor = 2.0f;

struct colour3 {
  uint8_t r, g, b;
};

struct hsv3 {
  uint8_t h, s, v;
};
static inline struct hsv3 mk_hsv3(uint8_t h, uint8_t s, uint8_t v)
{
  struct hsv3 res;
  res.h = h;
  res.s = s;
  res.v = v;
  return res;
}


static inline struct hsv3 mk_hsv3_f(float h, float s, float v)
{
  struct hsv3 res;
  res.h = roundf(h*255.0f);
  res.s = roundf(s*255.0f);
  res.v = roundf(v*255.0f);
  return res;
}


/* Number of migrating dots along one side of the migrating plane. */
#define MIG_SIDE LEDS_Y


/*
  Union with state data for all animations that need one. This way, a single
  statically-allocated memory area can be shared among all animations.
*/
union anim_data {
  struct st_fireworks {
    uint32_t num_phase1;
    uint32_t num_phase2;
    struct {
      float x[3],y[3],z[3],vx,vy,vz,s;
      struct hsv3 col;
      uint32_t base_frame, delay;
      float gl_base, gl_period, gl_amp;
    } p1[10];
    struct {
      float x,y,z,vx,vy,vz,hue;
      struct hsv3 col;
      uint32_t base_frame, delay;
      float fade_factor;
    } p2[300];
  } fireworks;

  struct st_migrating_dots {
    struct {
      float x,y,z,v, hue, sat, val, new_hue, new_sat, new_val;
      int target, delay;
    } dots[MIG_SIDE*MIG_SIDE];
    /* 0/1 is bottom/top, 2/3 is left/right, 4/5 is front/back. */
    int32_t start_plane, end_plane;
    uint32_t base_frame;
    uint32_t wait;
    uint32_t stage1;
    int text_idx;
  } migrating_dots[3];
};

struct ledtorus_anim;


/*
  Compute rectangular coordinates in the horizontal plane, taking into account
  the offset of the innermost LEDs from the center.
*/
struct torus_xz torus_polar2rect(float x, float a)
{
  struct torus_xz res;
  float angle = a * (F_PI*2.0f/(float)LEDS_TANG);
  res.x = (x+2.58f)*cosf(angle);
  res.z = (x+2.58f)*sinf(angle);
  return res;
}


/* Random integer 0 <= x < N. */
static int
irand(int n)
{
  return rand() / (RAND_MAX/n+1);
}

/* Random float 0 <= x <= N. */
static float
drand(float n)
{
  return (float)rand() / ((float)RAND_MAX/n);
}

/* Random unit vector of length a, uniform distribution in angular space. */
static void
vrand(float a, float *x, float *y, float *z)
{
  /*
    Sample a random direction uniformly.

    Uses the fact that cylinder projection of the sphere is area preserving,
    so sample uniformly the cylinder, and project onto the sphere.
  */
  float v = drand(2.0f*F_PI);
  float u = drand(2.0f) - 1.0f;
  float r = sqrtf(1.0f - u*u);
  *x = a*r*cosf(v);
  *y = a*r*sinf(v);
  *z = a*u;
}


static struct colour3
hsv2rgb_f(float h, float s, float v)
{
  /* From Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV */
  struct colour3 x;
  float c, m, r, g, b;

  c = v * s;
  h *= 6.0f;
  if (h < 1.0f)
  {
    r = c;
    g = c*h;
    b = 0.0f;
  }
  else if (h < 2.0f)
  {
    r = c*(2.0f - h);
    g = c;
    b = 0.0f;
  }
  else if (h < 3.0f)
  {
    r = 0.0f;
    g = c;
    b = c*(h - 2.0f);
  }
  else if (h < 4.0f)
  {
    r = 0.0f;
    g = c*(4.0f - h);
    b = c;
  }
  else if (h < 5.0f)
  {
    r = c*(h - 4.0f);
    g = 0.0f;
    b = c;
  }
  else /* h < 6.0f */
  {
    r = c;
    g = 0.0f;
    b = c*(6.0f - h);
  }
  m = v - c;
  /* Let's try to avoid rounding errors causing under/overflow. */
  x.r = (uint8_t)(0.1f + 255.8f*(r + m));
  x.g = (uint8_t)(0.1f + 255.8f*(g + m));
  x.b = (uint8_t)(0.1f + 255.8f*(b + m));
  return x;
}


void
cls(frame_t *f)
{
  memset(f, 0, sizeof(frame_t));
}


static const uint8_t tonc_font[8*96] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
  0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
  0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00,
  0x00, 0x66, 0xac, 0xd8, 0x36, 0x6a, 0xcc, 0x00,
  0x38, 0x6c, 0x68, 0x76, 0xdc, 0xce, 0x7b, 0x00,
  0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00,
  0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00,
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
  0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
  0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
  0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00,
  0x3c, 0x66, 0x6e, 0x7e, 0x76, 0x66, 0x3c, 0x00,
  0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x00,
  0x3c, 0x66, 0x06, 0x0c, 0x18, 0x30, 0x7e, 0x00,
  0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00,
  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x00,
  0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00,
  0x1c, 0x30, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00,
  0x7e, 0x06, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x00,
  0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00,
  0x3c, 0x66, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00,
  0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
  0x00, 0x06, 0x18, 0x60, 0x18, 0x06, 0x00, 0x00,
  0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x00, 0x60, 0x18, 0x06, 0x18, 0x60, 0x00, 0x00,
  0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00,
  0x3c, 0x66, 0x5a, 0x5a, 0x5e, 0x60, 0x3c, 0x00,
  0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00,
  0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00,
  0x1e, 0x30, 0x60, 0x60, 0x60, 0x30, 0x1e, 0x00,
  0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00,
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7e, 0x00,
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00,
  0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00,
  0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00,
  0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
  0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00,
  0xc6, 0xcc, 0xd8, 0xf0, 0xd8, 0xcc, 0xc6, 0x00,
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00,
  0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0x00,
  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
  0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00,
  0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00,
  0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xdc, 0x7e, 0x00,
  0x7c, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0x00,
  0x3c, 0x66, 0x70, 0x3c, 0x0e, 0x66, 0x3c, 0x00,
  0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00,
  0x66, 0x66, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x00,
  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
  0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00,
  0xc3, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x00,
  0xfe, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00,
  0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00,
  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x00,
  0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00,
  0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00,
  0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00,
  0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x00,
  0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00,
  0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x3e, 0x00,
  0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00,
  0x1c, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x30, 0x00,
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x3c,
  0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00,
  0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x0c, 0x00,
  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x78,
  0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0x00,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0c, 0x00,
  0x00, 0x00, 0xec, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00,
  0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00,
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60,
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06,
  0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00,
  0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 0x7c, 0x00,
  0x30, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x1c, 0x00,
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00,
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
  0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0x6c, 0x00,
  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x30,
  0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00,
  0x0c, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0c, 0x00,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
  0x30, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x30, 0x00,
  0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


static uint32_t
g_text(frame_t *f, const char *text, uint32_t x, uint32_t a,
       uint8_t c_r, uint8_t c_g, uint8_t c_b, float s_fact)
{
  uint8_t ch;
  float sofar;

  if (s_fact < 0.01f)
    return a;
  /* ToDo: support s_fact < 1. Requires skipping pixels, or merging them. */
  if (s_fact < 1.0f)
    s_fact = 1.0f;
  s_fact = 1.0f / s_fact;
  sofar = s_fact * 0.5f;

  while ((ch = *text++))
  {
    const uint8_t *font_p;
    uint8_t bit_pos;

    if (ch < 32 || ch > 127)
      ch = '?';
    font_p = &tonc_font[8*ch-8*' '];

    bit_pos = 0x80;
    while (bit_pos)
    {
      uint32_t y;
#if LEDS_Y < 8
#error g_text() requires at least 8 pixes in LEDS_Y direction.
#endif
      for (y = 0; y < 8; ++y)
      {
        if (font_p[y] & bit_pos)
          setpix(f, x, y, a, c_r, c_g, c_b);
      }

      if (a == 0)
        a = LEDS_TANG-1;
      else
        --a;
      sofar += s_fact;
      if (sofar >= 1.0f)
      {
        sofar -= 1.0f;
        bit_pos >>= 1;
      }
    }
  }

  return a;
}


void
envelope(frame_t *f, uint32_t c)
{
  uint32_t a, i;
  uint32_t c2;
  float fact;
  uint8_t c_b;

  c2 = c % 128;
  if (c2 < 32)
    fact = sinf((float)c2 * (F_PI/32.0f));
  else
    fact = 0.0f;
  c_b = (uint32_t)(17.0f + 30.0f*fact);

  cls(f);
  for (a = 0; a < LEDS_TANG; ++a)
  {
    for (i = 0; i < 16; ++i)
    {
      int x0;
      /* Inner edge. */
      x0 = (i < LEDS_Y/2 ? (LEDS_Y/2-1)-i : i-LEDS_Y/2);
      if (x0 >= 3)
        x0 -= 2;
      else if (x0 >= 1)
        x0 -= 1;
      setpix(f, x0, i, a, 0, 0, c_b);
      /* Outer edge. */
      setpix(f, 13, i, a, 0, 0, c_b);
      /* Bottom and top. */
      if (i < 7) {
        setpix(f, 12-i, 0, a, 0, 0, c_b);
        setpix(f, 12-i, 15, a, 0, 0, c_b);
      }
    }
  }
}


static uint32_t
an_test1(frame_t *f, uint32_t frame, union anim_data *data)
{
  cls(f);
  envelope(f, frame);
  return 0;
}


static uint32_t
an_test2(frame_t *f, uint32_t frame, union anim_data *data)
{
  int i;

  cls(f);
  for (i = 0; i < LEDS_TANG; ++i)
    setpix(f, LEDS_X/2, LEDS_Y/2, i, i, i, i);

  return 0;
}


static uint32_t
an_test3(frame_t *f, uint32_t frame, union anim_data *data)
{
  int i;
  uint8_t r, g, b;

  cls(f);
  r = 255;
  g = 0;
  b = 0;
  for (i = 0; i < 12; i += 3) {
    uint8_t tmp;

    setpix(f, LEDS_X-1, 1*LEDS_Y/4, i, r, g, b);
    setpix(f, LEDS_X-1, 2*LEDS_Y/4, i, b, r, g);
    setpix(f, LEDS_X-1, 3*LEDS_Y/4, i, g, b, r);
    tmp = b; b = g; g = r; r = tmp;
  }

  return 0;
}


int
main(int argc, char *argv[])
{
  uint32_t n;
  frame_t frame;
  static union anim_data private_data;

  for (n = 0; n < 5000; ++n)
  {
    uint8_t buf[512];
    size_t len = sizeof(frame_t);

    switch (argc > 1 ? atoi(argv[1]) : 0)
    {
    case 0:
      an_test1(&frame, n, NULL);
      break;
    case 1:
      an_test2(&frame, n, NULL);
      break;
    case 2:
    default:
      an_test3(&frame, n, NULL);
      break;
    }
    write(1, frame, len);
    if (len % 512)
    {
      memset(buf, 0, 512 - (len % 512));
      write(1, buf, 512 - (len % 512));
    }
  }
  return 0;
}
